#' Function to convert \code{longZight} objects to a format suitable for Lasagna plots
#'
#' Note: the data structure created by \code{recode_long_lasagna} can also be used by \code{\link{plot_long_alluvial}} for alternative display methods.
#'
#' @param .data A \code{longZight} object generated by \code{\link[longZight:load_long_data]{load_long_data}}
#' @param response The response variable to be plotted as an alluvial
#' @param sortorder Integer between 1 and 3. \code{1} for "By (factor) Level" mode, \code{2} for "By Count" mode and \code{3} for "By (contiguous) Block" mode.
#' @param completecases Logical variable to exclude incomplete cases
#' @param ts.args Logical, control to switch pharsing method for variable options
#' @examples
#' \dontrun{
#' mydata %>%
#'   load_long_data(IDind, WAVE) %>%
#'   refactor_wave %>%
#'   recode_long_lasagna(A5E, sortorder = 2, completecases = TRUE)
#' }
#' @return A \code{longZightLasagna} object
#' @export

recode_long_lasagna <- function(.data, response, sortorder,  completecases, ts.args) {
  UseMethod("recode_long_lasagna")
}

#' @rdname recode_long_lasagna
#' @method recode_long_lasagna longZight
#' @export
recode_long_lasagna.longZight <- function(.data, response, sortorder = 0, completecases = FALSE, ts.args = TRUE) {
  id_param <- attr(.data, 'lZid')
  wave_param <- attr(.data, 'lZwave')
  if (ts.args)
    values_param <- rlang::ensym(response)
  else
    values_param <- rlang::sym(response)

  if (!(c(values_param) %in% colnames(.data))) {
    stop("Response column missing.")
  }

  subset_data <- .data %>% dplyr::select(!!id_param, !!wave_param, !!values_param) %>%
    dplyr::rename(id = !!id_param, wave = !!wave_param, value = !!values_param)

  subset_data %<>% dplyr::arrange(wave) %>% tidyr::drop_na() %>% dplyr::mutate(wave = forcats::fct_drop(wave))
  waves_vect <- levels(dplyr::pull(subset_data, wave))
  chart_waves <- rlang::syms(paste0("value_", waves_vect))
  chart_sort <- rlang::syms(paste0("sortorder_", waves_vect))
  values_levels <- levels(dplyr::pull(subset_data, value))
  subset_data_w <- subset_data %>%
    tidyr::pivot_wider(names_from = wave, values_from= value, names_glue = "value_{wave}") %>%
    {
      if (completecases) tidyr::drop_na(.) else dplyr::mutate_if(., is.factor, forcats::fct_explicit_na)
    } %>%
    dplyr::group_by(!!!chart_waves) %>%
    dplyr::summarise(n = dplyr::n()) %>%
    dplyr::ungroup()
  subset_data_l <- subset_data_w %>%
    dplyr::mutate(id = dplyr::row_number()) %>%
    tidyr::pivot_longer(
      cols = starts_with("value_"),
      names_to = "wave",
      names_prefix = "value_",
      values_to = "value"
    )
  sortorders <- subset_data_l  %>%
    dplyr::group_by(wave, value) %>%
    dplyr::summarise(n = sum(n)) %>%
    dplyr::mutate(sortorder = rank(1/(c(n)+1), ties.method = "last")) %>%
    dplyr::select(-n)
  ret <- subset_data_l %>%
    dplyr::left_join(sortorders) %>%
    tidyr::pivot_wider(names_from = wave, values_from =c(value, sortorder)) %>%
    dplyr::select(id, n, !!!chart_waves, !!!chart_sort) %>%
    {
      if (sortorder == 1) dplyr::arrange(., desc(n)) else if (sortorder == 2) dplyr::arrange(., !!!chart_sort) else .
    } %>%
    dplyr::mutate(
      ymax = cumsum(n),
      ymin = ymin_calc(n),
      alluvid = dplyr::row_number()
    ) %>%
    tidyr::pivot_longer(
      cols = tidyselect::starts_with("value_"),
      names_to = "wave",
      names_prefix = "value_",
      values_to = "place"
    ) %>%
    dplyr::mutate(
      wave = as.factor(wave),
      xmin = as.numeric(wave) - 0.5,
      xmax = as.numeric(wave) + 0.5
    )

  class(ret) <- c("longZightLasagna", class(subset_data))
  attr(ret, 'wave_list') <- waves_vect
  return(ret)
}
